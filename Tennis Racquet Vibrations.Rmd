---
title: "Modeling Tennis Racquet Vibrations"
author: "Kaili Saffran"
date: "1/31/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(data.table)
library(rbenchmark)
```


# Flexible String With Fixed Ends:
## 3 Methods:
#### Data Table Approach:
```{r Flexible string - modified with data.table}

# New modified initial conditions:
## N <- 1001
## dx <- 0.32e-3
## dt <- 1e-8
## c <- 433.81
## displacement <- 0.01

# Function to insert initial conditions: 
String_Vibration1 <- function(N, time, dx, dt, c, displacement) {
  
C <- c*(dt/dx)

df <- data.table("time_step" = rep(c(0:time), each = (N)), 
                   "string_pos" = c(1:N), 
                   "ut" = rep(0, N))

# Initial conditions for ut:
df$ut[which(df$time_step == 0 & df$string_pos == 501)] <- displacement
df$ut[which(df$string_pos == 1)] = 0
df$ut[which(df$string_pos == N)] = 0

for(pos in 2:((N-1)/2)) {
  df$ut[pos] <- displacement * ((pos-1)/500)
  df$ut[(N+1)-pos] <- df$ut[pos]
}

for(pos in 1:N) {
  df$ut[N + pos] <- df$ut[pos]
}

# since we are making time step 0 and 1 identical, do not need the following code:
# df$ut[which(df$string_pos == 501 & df$t == 1)] <- df$ut[which(df$string_pos == 500 & df$t == 0)]

{
# String Vibration Simulation
  for (t in 1:(time-1)) {
    for (pos in 2:(N-1)) {  # Are doing fixed ends of the string
      df$ut[pos + N*(t+1)] = -df$ut[which(df$string_pos == pos & df$time_step == (t - 1))] + 
        2 * df$ut[which(df$string_pos == pos & df$time_step == t)] + (C ^ 2) * 
        (df$ut[which(df$string_pos == (pos + 1) & df$time_step == t)] - 
           2 * df$ut[which(df$string_pos == pos & df$time_step == t)] + 
           df$ut[which(df$string_pos == (pos - 1) & df$time_step == t)])
    }
    # save data:
    # save(df, file = "string_df1.Rdata")
    # how to tell how far in the simulation we are:
    # print(t)
  }
  # view the dataframe:
  # return(df)
}
}

String_Vibration1(1001, 10, 0.32e-3, 1e-8, 433.81, 0.01)

# plot every 10th time step:
# if (string_df1$t %% 10 == 0) {
#     plot(string_df1$ut~string_df1$string_pos, type = "l", col = "blue")
# }

# use facets to plot individual time steps:
# ggplot(string_df1, aes(string_pos, ut)) + geom_line(aes(group = time_step, col = time_step)) +
#   facet_grid(time_step ~ ., scales = "free_y", space = "free_y", shrink = F, margins = T)

# Check for difference between plots:
# plot(string_df1$ut[which(string_df1$time_step == 0)]~string_df1$string_pos[which(string_df1$time_step == 0)], type = "l", col = "blue")
# plot(string_df1$ut[which(string_df1$time_step == 1)]~string_df1$string_pos[which(string_df1$time_step == 1)], type = "l", col = "blue")
# plot(string_df1$ut[which(string_df1$time_step == 2)]~string_df1$string_pos[which(string_df1$time_step == 2)], type = "l", col = "blue")
# plot(string_df1$ut[which(string_df1$time_step == 3)]~string_df1$string_pos[which(string_df1$time_step == 3)], type = "l", col = "blue")
# plot(string_df1$ut[which(string_df1$time_step == 9000)]~string_df1$string_pos[which(string_df1$time_step == 9000)], type = "l", col = "blue")

# problem with this method: taking a very long time to spread across the string -> takes a long time to run
```


#### Matrix Approach:
```{r Flexible string - matrix}

String_Vibration2 <- function(N, time, dy, dt, c, displacement) {
  
C <- c*(dt/dx)

matrix(0, nrow = time, ncol = N) -> string_mat

# Initial conditions for matrix:
string_mat[1,501] <- displacement
string_mat[,1] = 0
string_mat[,N] = 0

for (t in 1) {
for(pos in 2:((N-1)/2)) {
  string_mat[t,pos] <- displacement * ((pos-1)/500)
  string_mat[t,((N+1)-pos)] <- string_mat[t,pos]
}
}

# Time step 0 and 1 are identical:
for (pos in 1:N) {
  string_mat[2, pos] <- string_mat[1, pos]
}

{
# String vibration simulation through matrix:
  for (t in 2:(time-1)) {
    for (pos in 2:(N-1)) {  # Are doing fixed ends of the string
      string_mat[(t+1),pos] = -string_mat[(t-1),pos] + 
        2 * string_mat[t,pos] + (C ^ 2) * 
        (string_mat[t,(pos+1)] - 
           2 * string_mat[t,pos] + 
           string_mat[t,(pos-1)])
    }
    # save data:
    # save(string_mat, file = "string_df2.Rdata")
    # print(t)
  }
  # View(string_mat)
}
}

String_Vibration2(1001, 10, 0.32e-3, 1e-8, 433.81, 0.01)
```


#### Vector Approach:
```{r Flexible string - vectors}

# Ran on another computer with more memory to try 1 million:
# cannot allocate vector of size 7.5 Gb for 1 million
# had to do 300,000 time steps:

String_Vibration3 <- function(N, time, dx, dt, c, displacement) {
  
C <- c*(dt/dx)

df <- data.table("ut" = rep(0, N*(time+1)))

df$ut -> ut

# Initial conditions for ut:
ut[501] <- displacement
ut[1] <- 0
ut[N] <- 0

for(pos in 2:((N-1)/2)) {
  ut[pos] <- displacement * ((pos-1)/500)
  ut[(N+1)-pos] <- ut[pos]
}

for(pos in 1:N) {
  ut[N + pos] <- ut[pos]
}

{
# String vibration simulation:
  for (t in 1:(time-1)) {
    for (pos in 2:(N-1)) {  # Are doing fixed ends of the string: ends are 0
      ut[pos + N*(t+1)] = -ut[pos + N*(t-1)] + 
        2 * ut[pos + N*t] + (C ^ 2) * 
        (ut[(pos+1) + N*t] - 
           2 * ut[pos + N*t] + 
           ut[(pos-1) + N*t])
    }
    # print(t)
  }
  # View(ut)
  save(ut, file = "string_df3.Rdata")
}
}

String_Vibration3(1001, 300000, 0.32e-3, 1e-8, 433.81, 0.01)

```


# Which Method Is Most Efficient?
```{r}
benchmark(String_Vibration1(1001, 10, 0.32e-3, 1e-8, 433.81, 0.01), String_Vibration2(1001, 10, 0.32e-3, 1e-8, 433.81, 0.01), String_Vibration3(1001, 10, 0.32e-3, 1e-8, 433.81, 0.01), replications = 2)
```
### The matrix and vector methods are most efficient in simulating through the racquet vibration. The data table method takes much longer. Since the matrix and vector methods are very close in terms of efficiency, I have decided to work with the vector method for the rest of my analysis. I chose this method over the matrix method because I found it easier to work with when displaying my results and changing code.

# Plot of Flexible String Vibration for Every 1000th Time Step:
```{r Plot of flexible string}

# after loading in string_df3.Rdata:
# after running 300,000 time steps and plotting every 1000th time step, we get results that show about 2 oscillations of the tennis racquet vibration:

String_Plot1 <- function(N, time) {
  for (t in 0:(time)) {
    if (t %% 1000 == 0) {
      plot(ut[(1 + (N * t)):(N + (N * t))])
    }
  }
}

String_Plot1(1001, 300000)

# used plot at time_step 36000 in paper:
# ut[36036501]
```



# Stiff String With Fixed Ends:
```{r Stiff string}

# Initial conditions:
## E <- 2.5 # GPa
## S <- 1.3e-6 # m
## K <- 0.0003225# m
## p <- 0.0013 # kg/m

String_Vibration4 <- function(N, time, dx, dt, c, displacement, E, S, K, p) {

M <- (E*S*(K)^2)/p
C <- c*(dt/dx)

df2 <- data.table("ut2" = rep(0, N*(time+1)))

df2$ut2 -> ut2

# Initial conditions for ut:
# derivatives of the ends of the string must be 0 as well:
ut2[501] <- displacement
ut2[1] <- 0
ut2[2] <- 0
ut2[N-1] <- 0
ut2[N] <- 0

for(pos in 3:((N-1)/2)) {
  ut2[pos] <- displacement * ((pos-1)/500)
  ut2[(N+1)-pos] <- ut2[pos]
}

for(pos in 1:N) {
  ut2[N + pos] <- ut2[pos]
}

{
# String vibration simulation:
  # still working with just t and (t-1) so do not need to determine initial conditions for additional variables: 
  for (t in 1:(time-1)) {
    for (pos in 3:(N-2)) {  # Are doing fixed ends of the string
      ut2[pos + N*(t+1)] = -ut2[pos + N*(t-1)] + 
        2 * ut2[pos + N*t] + (C ^ 2) * 
        (ut2[(pos+1) + N*t] - 
           2 * ut2[pos + N*t] + 
           ut2[(pos-1) + N*t]) - (M)*((dt^2)/(dx^4)) *
        (ut2[(pos+1) + N*t] -
           4 * ut2[pos + N*t] +
        6 * ut2[(pos-1) + N*t] -
        4 * ut2[(pos-2) + N*t] +
          ut2[(pos-3) + N*t])
    }
    # print(t)
  }
  # View(ut2)
  # once run, do not need to run again:
  save(ut2, file = "string_df4.Rdata")
}
}

# adjust number of time steps based on non-stiff string simulation:
String_Vibration4(1001, 300000, 0.32e-3, 1e-8, 433.81, 0.01, 2.5, 1.3e-6, 0.0003225, 0.0013)

```



# Plot of Stiff String Vibration for Every 1000th Time Step:
```{r Plot of stiff string}

# after loading in string_df4.Rdata:

String_Plot2 <- function(N, time) {
  for (t in 0:(time)) {
    if (t %% 1000 == 0) {
      plot(ut2[(1 + (N * t)):(N + (N * t))])
    }
  }
}

String_Plot2(1001, 300000)

# Note: appears fairly similar to 2nd order PDE
# used plot at time_step 36000 in paper:
# ut2[36036501]
```


# Crossed Stiff Strings with Fixed Ends
```{r Crossed string}

# Initial conditions:

# length of new string is 0.24 m:
  ## dx = 0.24e-3 # m
## dy = 0.32e-3 # m
## dt = 1e-8
## c = 433.81 # m/s
## displacement1 = 0.01 - 0.00129 # m
## displacement2 = 0.01 # m
## tension = 244.65 # N
## E = 2.5 # GPa
## S <- 1.3e-6 # m
## K = 0.0003225 # m
## p = 0.0013 # kg/m

# ---------------------------------------------
# the following is not relevant:
# how much force is one string putting on the other?
  ## 0.22 Ibs or 0.98 N # if u_yt (longer string) is on top
  ## or..
  ## 0.30 Ibs or 1.33 N # if u_xt (shorter string) is on top
  ## is this logical?? Answer: Not really
# ---------------------------------------------

String_Vibration5 <- function(N, time, dx, dy, dt, c, displacement1, displacement2, tension, E, S, K, p) {

M <- (E*S*(K)^2)/p
Cx <- c*(dt/dx)
Cy <- c*(dt/dy)

# ----------------------------------------------------------
# the following is not a suitable method:
# use an array since it allows you to work in 3 dimensions?
  # array will be too big and will not run:
  # ut <- array(0, dim = c(N, N, time)) # with 10 time steps this generates an array of 10 million elements
   # will not be able to run this...
# ----------------------------------------------------------

# use two vectors:
df3 <- data.table("u_xt" = rep(0, N*(time+1)),
                  "u_yt" = rep(0, N*(time+1)))

# this will be the shorter of the two strings:
df3$u_xt -> u_xt
# this will be the longer of the two strings:
df3$u_yt -> u_yt

# ---------------------------------------
# not needed:
# ut <- u_xt[order(match(u_xt, u_yt))]
# ---------------------------------------

# Initial conditions for u_xt:
# derivatives of the ends of the string must be 0 as well:
# we are assuming the shorter string is underneath the longer string:
u_xt[501] <- displacement1
u_xt[1] <- 0
u_xt[2] <- 0
u_xt[N-1] <- 0
u_xt[N] <- 0

# Initial conditions for u_yt:
# derivatives of the ends of the string must be 0 as well:
# we are assuming the longer string is on top of the shorter string:
u_yt[501] <- displacement2
u_yt[1] <- 0 
u_yt[2] <- 0 
u_yt[N-1] <- 0
u_yt[N] <- 0

for(pos in 3:((N-1)/2)) {
  u_xt[pos] <- displacement1 * ((pos-1)/500)
  u_xt[(N+1)-pos] <- u_xt[pos]
  u_yt[pos] <- displacement2 * ((pos-1)/500)
  u_yt[(N+1)-pos] <- u_yt[pos]
}

for(pos in 1:N) {
  u_xt[N + pos] <- u_xt[pos]
  u_yt[N + pos] <- u_yt[pos]
}

{
# String vibration simulation:
  # still working with just t and (t-1) so do not need to determine initial conditions for additional variables: 
  # determined that the intersection point of the strings is between positions 497-504, hence the multiple for loops:
  for (t in 1:(time-1)) {
    
    # first half of the strings:
    for (pos in 3:496) {
      
      u_xt[pos + N * (t + 1)] = -u_xt[pos + N * (t - 1)] +
        2 * u_xt[pos + N * t] + (Cx ^ 2) *
        (u_xt[(pos + 1) + N * t] -
           2 * u_xt[pos + N * t] +
           u_xt[(pos - 1) + N * t]) - (M) * ((dt ^ 2) / (dx ^ 4)) *
        (u_xt[(pos + 1) + N * t] -
           4 * u_xt[pos + N * t] +
           6 * u_xt[(pos - 1) + N * t] -
           4 * u_xt[(pos - 2) + N * t] +
           u_xt[(pos - 3) + N * t])
      
      u_yt[pos + N * (t + 1)] = -u_yt[pos + N * (t - 1)] +
        2 * u_yt[pos + N * t] + (Cy ^ 2) *
        (u_yt[(pos + 1) + N * t] -
           2 * u_yt[pos + N * t] +
           u_yt[(pos - 1) + N * t]) - (M) * ((dt ^ 2) / (dx ^ 4)) *
        (u_yt[(pos + 1) + N * t] -
           4 * u_yt[pos + N * t] +
           6 * u_yt[(pos - 1) + N * t] -
           4 * u_yt[(pos - 2) + N * t] +
           u_yt[(pos - 3) + N * t])
    }
    
    # second half of the strings:
    for (pos in 505:(N - 2)) {
      
      u_xt[pos + N * (t + 1)] = -u_xt[pos + N * (t - 1)] +
        2 * u_xt[pos + N * t] + (Cx ^ 2) *
        (u_xt[(pos + 1) + N * t] -
           2 * u_xt[pos + N * t] +
           u_xt[(pos - 1) + N * t]) - (M) * ((dt ^ 2) / (dx ^ 4)) *
        (u_xt[(pos + 1) + N * t] -
           4 * u_xt[pos + N * t] +
           6 * u_xt[(pos - 1) + N * t] -
           4 * u_xt[(pos - 2) + N * t] +
           u_xt[(pos - 3) + N * t])
      
      u_yt[pos + N * (t + 1)] = -u_yt[pos + N * (t - 1)] +
        2 * u_yt[pos + N * t] + (Cy ^ 2) *
        (u_yt[(pos + 1) + N * t] -
           2 * u_yt[pos + N * t] +
           u_yt[(pos - 1) + N * t]) - (M) * ((dt ^ 2) / (dx ^ 4)) *
        (u_yt[(pos + 1) + N * t] -
           4 * u_yt[pos + N * t] +
           6 * u_yt[(pos - 1) + N * t] -
           4 * u_yt[(pos - 2) + N * t] +
           u_yt[(pos - 3) + N * t])
    }
    
    # where the two strings intersect:
    for (pos in 497:504) {
      
      # assuming shorter string on bottom:
      u_xt[pos + N * (t + 1)] = -u_xt[pos + N * (t - 1)] +
        2 * u_xt[pos + N * t] + (Cx ^ 2) *
        (u_xt[(pos + 1) + N * t] -
           2 * u_xt[pos + N * t] +
           u_xt[(pos - 1) + N * t]) - (M) * ((dt ^ 2) / (dx ^ 4)) *
        (u_xt[(pos + 1) + N * t] -
           4 * u_xt[pos + N * t] +
           6 * u_xt[(pos - 1) + N * t] -
           4 * u_xt[(pos - 2) + N * t] +
           u_xt[(pos - 3) + N * t]) - ((tension * dy)/(c^2)) *   
           
            # Initially 0.08; assume this is ok from literature
            # The next terms are the tangents of the angles
            # Initial angle = tan^{-1} ( 0.01 m / .16 m ) is about
            #    0.0625 radians. We're getting 5e-6. This is fixed with the code below:
        
            (((u_yt[497 + (N*t)] - u_yt[496 + (N*t)]) / dy) * (p) +
               ((u_yt[504 + (N*t)] - u_yt[505 + (N*t)]) / dy) * (p))
      
      # assuming longer string is on top:
      u_yt[pos + N * (t + 1)] = -u_yt[pos + N * (t - 1)] +
        2 * u_yt[pos + N * t] + (Cy ^ 2) *
        (u_yt[(pos + 1) + N * t] -
           2 * u_yt[pos + N * t] +
           u_yt[(pos - 1) + N * t]) - (M) * ((dt ^ 2) / (dx ^ 4)) *
        (u_yt[(pos + 1) + N * t] -
           4 * u_yt[pos + N * t] +
           6 * u_yt[(pos - 1) + N * t] -
           4 * u_yt[(pos - 2) + N * t] +
           u_yt[(pos - 3) + N * t]) + ((tension * dy)/(c^2)) *   
            (((u_yt[497 + (N*t)] - u_yt[496 + (N*t)]) / dy) * (p) +
               ((u_yt[504 + (N*t)] - u_yt[505 + (N*t)]) / dy) * (p))
    }
    # print(t)
    }
  # View(u_xt)
  # View(u_yt)
  save(u_xt, file = "string_df5.Rdata")
  save(u_yt, file = "string_df6.Rdata")
}
}

String_Vibration5(1001, 300000, 0.24e-3, 0.32e-3, 1e-8, 433.81, 0.00871, 0.01, 244.65, 2.5, 1.3e-6, 0.0003225, 0.0013)

```



# Plot of Crossed String Vibration for Every 1000th Time Step: u_xt
```{r}

# after loading in string_df5.Rdata:

String_Plot3 <- function(N, time) {
  for (t in 0:(time)) {
    if (t %% 1000 == 0) {
      plot(u_xt[(1 + (N * t)):(N + (N * t))])
    }
  }
}

String_Plot3(1001, 300000)

# used plot at time_step 27000 in paper:
# u_xt[27027501]
```


# Plot of Crossed String Vibration for Every 1000th Time Step: u_yt
```{r}

# after loading in string_df6.Rdata:

String_Plot4 <- function(N, time) {
  for (t in 0:(time)) {
    if (t %% 1000 == 0) {
      plot(u_yt[(1 + (N * t)):(N + (N * t))])
    }
  }
}

String_Plot4(1001, 300000)

# used plot at time_step 36000 in paper:
# u_yt[36036501]
```


